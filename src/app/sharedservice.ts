/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAssetCategoryClient {
    getAllAssetCategory(): Observable<AssetCategoryModel[] | null>;
    saveAssetCategory(assetCategoryModel: AssetCategoryModel): Observable<ResponseModel | null>;
    getAssetCategoryById(assetCategoryId?: number | undefined): Observable<DepartmentModel | null>;
    deleteAssetCategory(assetCategoryId?: number | undefined): Observable<ResponseModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class AssetCategoryClient implements IAssetCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllAssetCategory(): Observable<AssetCategoryModel[] | null> {
        let url_ = this.baseUrl + "/api/assetCategory/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<AssetCategoryModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetCategoryModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetCategory(response: HttpResponseBase): Observable<AssetCategoryModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCategoryModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetCategoryModel[] | null>(<any>null);
    }

    saveAssetCategory(assetCategoryModel: AssetCategoryModel): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/assetCategory/AddAssetCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assetCategoryModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAssetCategory(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    getAssetCategoryById(assetCategoryId?: number | undefined): Observable<DepartmentModel | null> {
        let url_ = this.baseUrl + "/api/assetCategory/GetAssetCategory?";
        if (assetCategoryId === null)
            throw new Error("The parameter 'assetCategoryId' cannot be null.");
        else if (assetCategoryId !== undefined)
            url_ += "assetCategoryId=" + encodeURIComponent("" + assetCategoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetCategoryById(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetCategoryById(response: HttpResponseBase): Observable<DepartmentModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DepartmentModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentModel | null>(<any>null);
    }

    deleteAssetCategory(assetCategoryId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/assetCategory/DeleteAssetCategory?";
        if (assetCategoryId === null)
            throw new Error("The parameter 'assetCategoryId' cannot be null.");
        else if (assetCategoryId !== undefined)
            url_ += "assetCategoryId=" + encodeURIComponent("" + assetCategoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetCategory(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }
}

export interface IAssetClient {
    getAllAsset(): Observable<AssetModel[] | null>;
    getAllAssetTag(): Observable<AssetModel[] | null>;
    getAllAssetCategory(): Observable<AssetCategoryModel[] | null>;
    getAllVendor(): Observable<VendorModel[] | null>;
    saveAsset(assetData?: string | null | undefined): Observable<ResponseModel | null>;
    updateAsset(assetData?: string | null | undefined): Observable<ResponseModel | null>;
    deleteAsset(assetId?: number | undefined): Observable<ResponseModel | null>;
    getAssetById(assetId?: number | undefined): Observable<AssetModel | null>;
    downloadDocument(documentId?: string | null | undefined): Observable<DocumentModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class AssetClient implements IAssetClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllAsset(): Observable<AssetModel[] | null> {
        let url_ = this.baseUrl + "/api/Asset/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAsset(response: HttpResponseBase): Observable<AssetModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModel[] | null>(<any>null);
    }

    getAllAssetTag(): Observable<AssetModel[] | null> {
        let url_ = this.baseUrl + "/api/Asset/GetAllAssetTag";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetTag(<any>response_);
                } catch (e) {
                    return <Observable<AssetModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetTag(response: HttpResponseBase): Observable<AssetModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModel[] | null>(<any>null);
    }

    getAllAssetCategory(): Observable<AssetCategoryModel[] | null> {
        let url_ = this.baseUrl + "/api/Asset/GetAllAssetCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetCategory(<any>response_);
                } catch (e) {
                    return <Observable<AssetCategoryModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetCategoryModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetCategory(response: HttpResponseBase): Observable<AssetCategoryModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetCategoryModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetCategoryModel[] | null>(<any>null);
    }

    getAllVendor(): Observable<VendorModel[] | null> {
        let url_ = this.baseUrl + "/api/Asset/GetAllVendor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendor(<any>response_);
                } catch (e) {
                    return <Observable<VendorModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendor(response: HttpResponseBase): Observable<VendorModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VendorModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorModel[] | null>(<any>null);
    }

    saveAsset(assetData?: string | null | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/Asset/AddAsset?";
        if (assetData !== undefined)
            url_ += "assetData=" + encodeURIComponent("" + assetData) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAsset(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAsset(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    updateAsset(assetData?: string | null | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/Asset/UpdateAsset?";
        if (assetData !== undefined)
            url_ += "assetData=" + encodeURIComponent("" + assetData) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAsset(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAsset(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    deleteAsset(assetId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/Asset/DeleteAsset?";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAsset(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAsset(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    getAssetById(assetId?: number | undefined): Observable<AssetModel | null> {
        let url_ = this.baseUrl + "/api/Asset/GetAsset?";
        if (assetId === null)
            throw new Error("The parameter 'assetId' cannot be null.");
        else if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetById(<any>response_);
                } catch (e) {
                    return <Observable<AssetModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetById(response: HttpResponseBase): Observable<AssetModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssetModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModel | null>(<any>null);
    }

    downloadDocument(documentId?: string | null | undefined): Observable<DocumentModel | null> {
        let url_ = this.baseUrl + "/api/Asset/DownloadDocument?";
        if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDocument(<any>response_);
                } catch (e) {
                    return <Observable<DocumentModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadDocument(response: HttpResponseBase): Observable<DocumentModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentModel | null>(<any>null);
    }
}

export interface IAssetGatePassClient {
    getAllAssetGatePassList(): Observable<AssetGatePassModel[] | null>;
    getAllGatePassType(): Observable<GatePassTypeModel[] | null>;
    getAllUnit(): Observable<QuantityUnitModel[] | null>;
    getBlankGatePassDetail(): Observable<AssetGatePassDetailModel | null>;
    getGatePassDetailById(gatePassId?: number | undefined): Observable<AssetGatePassModel | null>;
    saveAssetGatePass(assetGatePassModel: AssetGatePassModel): Observable<ResponseModel | null>;
    deleteAssetGatePass(gatePassId?: number | undefined): Observable<ResponseModel | null>;
    updateGatePassStatus(assetGatePass: AssetGatePassModel): Observable<ResponseModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class AssetGatePassClient implements IAssetGatePassClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllAssetGatePassList(): Observable<AssetGatePassModel[] | null> {
        let url_ = this.baseUrl + "/api/GatePass/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetGatePassList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetGatePassList(<any>response_);
                } catch (e) {
                    return <Observable<AssetGatePassModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetGatePassModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetGatePassList(response: HttpResponseBase): Observable<AssetGatePassModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetGatePassModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetGatePassModel[] | null>(<any>null);
    }

    getAllGatePassType(): Observable<GatePassTypeModel[] | null> {
        let url_ = this.baseUrl + "/api/GatePass/GetAllGatePassType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGatePassType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGatePassType(<any>response_);
                } catch (e) {
                    return <Observable<GatePassTypeModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<GatePassTypeModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGatePassType(response: HttpResponseBase): Observable<GatePassTypeModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GatePassTypeModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GatePassTypeModel[] | null>(<any>null);
    }

    getAllUnit(): Observable<QuantityUnitModel[] | null> {
        let url_ = this.baseUrl + "/api/GatePass/GetAllUnit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUnit(<any>response_);
                } catch (e) {
                    return <Observable<QuantityUnitModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuantityUnitModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUnit(response: HttpResponseBase): Observable<QuantityUnitModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuantityUnitModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuantityUnitModel[] | null>(<any>null);
    }

    getBlankGatePassDetail(): Observable<AssetGatePassDetailModel | null> {
        let url_ = this.baseUrl + "/api/GatePass/GetBlankGatePassDetail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlankGatePassDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlankGatePassDetail(<any>response_);
                } catch (e) {
                    return <Observable<AssetGatePassDetailModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetGatePassDetailModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlankGatePassDetail(response: HttpResponseBase): Observable<AssetGatePassDetailModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssetGatePassDetailModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetGatePassDetailModel | null>(<any>null);
    }

    getGatePassDetailById(gatePassId?: number | undefined): Observable<AssetGatePassModel | null> {
        let url_ = this.baseUrl + "/api/GatePass/GetGatePassById?";
        if (gatePassId === null)
            throw new Error("The parameter 'gatePassId' cannot be null.");
        else if (gatePassId !== undefined)
            url_ += "gatePassId=" + encodeURIComponent("" + gatePassId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGatePassDetailById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGatePassDetailById(<any>response_);
                } catch (e) {
                    return <Observable<AssetGatePassModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetGatePassModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetGatePassDetailById(response: HttpResponseBase): Observable<AssetGatePassModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssetGatePassModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetGatePassModel | null>(<any>null);
    }

    saveAssetGatePass(assetGatePassModel: AssetGatePassModel): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/GatePass/SaveAssetGatePass";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assetGatePassModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAssetGatePass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAssetGatePass(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAssetGatePass(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    deleteAssetGatePass(gatePassId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/GatePass/DeleteAssetGatePass?";
        if (gatePassId === null)
            throw new Error("The parameter 'gatePassId' cannot be null.");
        else if (gatePassId !== undefined)
            url_ += "gatePassId=" + encodeURIComponent("" + gatePassId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssetGatePass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssetGatePass(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssetGatePass(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    updateGatePassStatus(assetGatePass: AssetGatePassModel): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/GatePass/UpdateGatePassStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assetGatePass);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGatePassStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGatePassStatus(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGatePassStatus(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }
}

export interface IAuthClient {
    authenticate(userLogin: LoginDetails): Observable<UserModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    authenticate(userLogin: LoginDetails): Observable<UserModel | null> {
        let url_ = this.baseUrl + "/api/Auth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userLogin);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<UserModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<UserModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserModel | null>(<any>null);
    }
}

export interface ICompanyClient {
    getAllCompany(): Observable<CompanyModel[] | null>;
    saveCompany(companyData?: string | null | undefined): Observable<ResponseModel | null>;
    updateCompany(companyData?: string | null | undefined): Observable<ResponseModel | null>;
    getCompanyById(companyId?: number | undefined): Observable<CompanyModel | null>;
    deleteCompany(companyId?: number | undefined): Observable<ResponseModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class CompanyClient implements ICompanyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllCompany(): Observable<CompanyModel[] | null> {
        let url_ = this.baseUrl + "/api/company/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCompany(<any>response_);
                } catch (e) {
                    return <Observable<CompanyModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCompany(response: HttpResponseBase): Observable<CompanyModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyModel[] | null>(<any>null);
    }

    saveCompany(companyData?: string | null | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/company/SaveCompany?";
        if (companyData !== undefined)
            url_ += "companyData=" + encodeURIComponent("" + companyData) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCompany(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveCompany(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    updateCompany(companyData?: string | null | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/company/UpdateCompany?";
        if (companyData !== undefined)
            url_ += "companyData=" + encodeURIComponent("" + companyData) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompany(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCompany(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    getCompanyById(companyId?: number | undefined): Observable<CompanyModel | null> {
        let url_ = this.baseUrl + "/api/company/GetCompany?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyById(<any>response_);
                } catch (e) {
                    return <Observable<CompanyModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyById(response: HttpResponseBase): Observable<CompanyModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyModel | null>(<any>null);
    }

    deleteCompany(companyId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/company/DeleteCompany?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompany(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCompany(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }
}

export interface IDashboardClient {
    getAllDashboardData(userId?: number | undefined): Observable<DashboardModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class DashboardClient implements IDashboardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllDashboardData(userId?: number | undefined): Observable<DashboardModel | null> {
        let url_ = this.baseUrl + "/api/department/GetAllDashboardData?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<DashboardModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDashboardData(response: HttpResponseBase): Observable<DashboardModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DashboardModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardModel | null>(<any>null);
    }
}

export interface IDepartmentClient {
    getAllDepartments(): Observable<DepartmentModel[] | null>;
    saveDepartment(departmentModel: DepartmentModel): Observable<ResponseModel | null>;
    getDepartmentById(departmentId?: number | undefined): Observable<DepartmentModel | null>;
    deleteDepartment(departmentId?: number | undefined): Observable<ResponseModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class DepartmentClient implements IDepartmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllDepartments(): Observable<DepartmentModel[] | null> {
        let url_ = this.baseUrl + "/api/department/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartments(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDepartments(response: HttpResponseBase): Observable<DepartmentModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentModel[] | null>(<any>null);
    }

    saveDepartment(departmentModel: DepartmentModel): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/department/AddDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(departmentModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDepartment(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveDepartment(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    getDepartmentById(departmentId?: number | undefined): Observable<DepartmentModel | null> {
        let url_ = this.baseUrl + "/api/department/GetDepartment?";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentById(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentById(response: HttpResponseBase): Observable<DepartmentModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DepartmentModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentModel | null>(<any>null);
    }

    deleteDepartment(departmentId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/department/DeleteDepartment?";
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDepartment(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDepartment(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }
}

export interface IReportClient {
    getAllGatePassStatus(): Observable<StatusModel[] | null>;
    getGatePassSummaryReport(): Observable<AssetGatePassModel[] | null>;
    getGatePassReportWithItems(): Observable<ReportModel[] | null>;
}

@Injectable({
    providedIn: 'root'
})
export class ReportClient implements IReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllGatePassStatus(): Observable<StatusModel[] | null> {
        let url_ = this.baseUrl + "/api/report/GetAllGatePassStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGatePassStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGatePassStatus(<any>response_);
                } catch (e) {
                    return <Observable<StatusModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGatePassStatus(response: HttpResponseBase): Observable<StatusModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusModel[] | null>(<any>null);
    }

    getGatePassSummaryReport(): Observable<AssetGatePassModel[] | null> {
        let url_ = this.baseUrl + "/api/report/GetGatePassSummaryReport";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGatePassSummaryReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGatePassSummaryReport(<any>response_);
                } catch (e) {
                    return <Observable<AssetGatePassModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetGatePassModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetGatePassSummaryReport(response: HttpResponseBase): Observable<AssetGatePassModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetGatePassModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetGatePassModel[] | null>(<any>null);
    }

    getGatePassReportWithItems(): Observable<ReportModel[] | null> {
        let url_ = this.baseUrl + "/api/report/GetGatePassReportWithItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGatePassReportWithItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGatePassReportWithItems(<any>response_);
                } catch (e) {
                    return <Observable<ReportModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetGatePassReportWithItems(response: HttpResponseBase): Observable<ReportModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReportModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportModel[] | null>(<any>null);
    }
}

export interface IRoleClient {
    getUserRoleMenuFunctions(roleId?: number | undefined): Observable<UserRoleModel | null>;
    getAllRole(): Observable<RoleModel[] | null>;
    getBlankRoleMenu(): Observable<RoleMenuModel | null>;
    getRoleMenuList(roleId?: number | undefined): Observable<MenuModel[] | null>;
    getRoleFunctionList(roleId?: number | undefined): Observable<FunctionModel[] | null>;
    saveRole(roleModel: RoleModel): Observable<ResponseModel | null>;
    getRoleById(roleId?: number | undefined): Observable<RoleModel | null>;
    deleteRole(roleId?: number | undefined): Observable<ResponseModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class RoleClient implements IRoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUserRoleMenuFunctions(roleId?: number | undefined): Observable<UserRoleModel | null> {
        let url_ = this.baseUrl + "/api/role/UserRoleMenuFunction?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoleMenuFunctions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoleMenuFunctions(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRoleModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserRoleMenuFunctions(response: HttpResponseBase): Observable<UserRoleModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserRoleModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRoleModel | null>(<any>null);
    }

    getAllRole(): Observable<RoleModel[] | null> {
        let url_ = this.baseUrl + "/api/role/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRole(response: HttpResponseBase): Observable<RoleModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleModel[] | null>(<any>null);
    }

    getBlankRoleMenu(): Observable<RoleMenuModel | null> {
        let url_ = this.baseUrl + "/api/role/GetBlankRoleMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlankRoleMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlankRoleMenu(<any>response_);
                } catch (e) {
                    return <Observable<RoleMenuModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleMenuModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBlankRoleMenu(response: HttpResponseBase): Observable<RoleMenuModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleMenuModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleMenuModel | null>(<any>null);
    }

    getRoleMenuList(roleId?: number | undefined): Observable<MenuModel[] | null> {
        let url_ = this.baseUrl + "/api/role/GetRoleMenu?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleMenuList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleMenuList(<any>response_);
                } catch (e) {
                    return <Observable<MenuModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleMenuList(response: HttpResponseBase): Observable<MenuModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuModel[] | null>(<any>null);
    }

    getRoleFunctionList(roleId?: number | undefined): Observable<FunctionModel[] | null> {
        let url_ = this.baseUrl + "/api/role/GetRoleFunction?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleFunctionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleFunctionList(<any>response_);
                } catch (e) {
                    return <Observable<FunctionModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FunctionModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleFunctionList(response: HttpResponseBase): Observable<FunctionModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FunctionModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FunctionModel[] | null>(<any>null);
    }

    saveRole(roleModel: RoleModel): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/role/AddRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRole(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveRole(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    getRoleById(roleId?: number | undefined): Observable<RoleModel | null> {
        let url_ = this.baseUrl + "/api/role/GetRole?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(<any>response_);
                } catch (e) {
                    return <Observable<RoleModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<RoleModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleModel | null>(<any>null);
    }

    deleteRole(roleId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/role/DeleteRole?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }
}

export interface IUserClient {
    getRoleList(): Observable<RoleModel[] | null>;
    getDepartmentList(): Observable<DepartmentModel[] | null>;
    getAllUser(): Observable<UserModel[] | null>;
    deleteUser(userId?: number | undefined): Observable<ResponseModel | null>;
    saveUser(user: UserModel): Observable<ResponseModel | null>;
    getUserDetailById(userId?: number | undefined): Observable<ResponseModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getRoleList(): Observable<RoleModel[] | null> {
        let url_ = this.baseUrl + "/api/user/GetRoleList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleList(<any>response_);
                } catch (e) {
                    return <Observable<RoleModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleList(response: HttpResponseBase): Observable<RoleModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleModel[] | null>(<any>null);
    }

    getDepartmentList(): Observable<DepartmentModel[] | null> {
        let url_ = this.baseUrl + "/api/user/GetDepartmentList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentList(<any>response_);
                } catch (e) {
                    return <Observable<DepartmentModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<DepartmentModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentList(response: HttpResponseBase): Observable<DepartmentModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DepartmentModel[] | null>(<any>null);
    }

    getAllUser(): Observable<UserModel[] | null> {
        let url_ = this.baseUrl + "/api/user/GetAllUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUser(<any>response_);
                } catch (e) {
                    return <Observable<UserModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUser(response: HttpResponseBase): Observable<UserModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserModel[] | null>(<any>null);
    }

    deleteUser(userId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/user/DeleteUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    saveUser(user: UserModel): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/user/SaveUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUser(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUser(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    getUserDetailById(userId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/user/GetUserDetailById?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetailById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetailById(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDetailById(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }
}

export interface IVendorClient {
    getAllVendor(): Observable<VendorModel[] | null>;
    saveVendor(vendorModel: VendorModel): Observable<ResponseModel | null>;
    getVendorById(vendorId?: number | undefined): Observable<VendorModel | null>;
    deleteVendor(vendorId?: number | undefined): Observable<ResponseModel | null>;
}

@Injectable({
    providedIn: 'root'
})
export class VendorClient implements IVendorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAllVendor(): Observable<VendorModel[] | null> {
        let url_ = this.baseUrl + "/api/vendor/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendor(<any>response_);
                } catch (e) {
                    return <Observable<VendorModel[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorModel[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendor(response: HttpResponseBase): Observable<VendorModel[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VendorModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorModel[] | null>(<any>null);
    }

    saveVendor(vendorModel: VendorModel): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/vendor/AddVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(vendorModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVendor(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveVendor(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }

    getVendorById(vendorId?: number | undefined): Observable<VendorModel | null> {
        let url_ = this.baseUrl + "/api/vendor/GetVendor?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorById(<any>response_);
                } catch (e) {
                    return <Observable<VendorModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorById(response: HttpResponseBase): Observable<VendorModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? VendorModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorModel | null>(<any>null);
    }

    deleteVendor(vendorId?: number | undefined): Observable<ResponseModel | null> {
        let url_ = this.baseUrl + "/api/vendor/DeleteVendor?";
        if (vendorId === null)
            throw new Error("The parameter 'vendorId' cannot be null.");
        else if (vendorId !== undefined)
            url_ += "vendorId=" + encodeURIComponent("" + vendorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVendor(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVendor(response: HttpResponseBase): Observable<ResponseModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResponseModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel | null>(<any>null);
    }
}

export class AssetCategoryModel implements IAssetCategoryModel {
    id!: number;
    categoryName?: string | undefined;
    isActive?: boolean | undefined;
    createdBy!: number;
    createdDate!: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;

    constructor(data?: IAssetCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.categoryName = data["categoryName"];
            this.isActive = data["isActive"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = data["modifiedBy"];
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AssetCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssetCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryName"] = this.categoryName;
        data["isActive"] = this.isActive;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAssetCategoryModel {
    id: number;
    categoryName?: string | undefined;
    isActive?: boolean | undefined;
    createdBy: number;
    createdDate: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
}

export class ResponseModel implements IResponseModel {
    statusCode!: number;
    statusText?: string | undefined;
    message?: string | undefined;
    isSuccess!: boolean;
    isExist!: boolean;
    gatePassNo?: string | undefined;

    constructor(data?: IResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.statusCode = data["statusCode"];
            this.statusText = data["statusText"];
            this.message = data["message"];
            this.isSuccess = data["isSuccess"];
            this.isExist = data["isExist"];
            this.gatePassNo = data["gatePassNo"];
        }
    }

    static fromJS(data: any): ResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["statusText"] = this.statusText;
        data["message"] = this.message;
        data["isSuccess"] = this.isSuccess;
        data["isExist"] = this.isExist;
        data["gatePassNo"] = this.gatePassNo;
        return data; 
    }
}

export interface IResponseModel {
    statusCode: number;
    statusText?: string | undefined;
    message?: string | undefined;
    isSuccess: boolean;
    isExist: boolean;
    gatePassNo?: string | undefined;
}

export class DepartmentModel implements IDepartmentModel {
    id!: number;
    departmentName?: string | undefined;
    isActive!: boolean;
    createdBy!: number;
    createdDate!: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;

    constructor(data?: IDepartmentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.departmentName = data["departmentName"];
            this.isActive = data["isActive"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = data["modifiedBy"];
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DepartmentModel {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["departmentName"] = this.departmentName;
        data["isActive"] = this.isActive;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDepartmentModel {
    id: number;
    departmentName?: string | undefined;
    isActive: boolean;
    createdBy: number;
    createdDate: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
}

export class AssetModel implements IAssetModel {
    id!: number;
    assetTagId?: string | undefined;
    assetName?: string | undefined;
    assetCategoryId!: number;
    assetDescription?: string | undefined;
    isActive!: boolean;
    createdBy!: number;
    createdDate!: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    documentList?: DocumentModel[] | undefined;
    assetCategory?: AssetCategoryModel | undefined;
    assetDetail?: AssetDetailModel[] | undefined;

    constructor(data?: IAssetModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.assetTagId = data["assetTagId"];
            this.assetName = data["assetName"];
            this.assetCategoryId = data["assetCategoryId"];
            this.assetDescription = data["assetDescription"];
            this.isActive = data["isActive"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = data["modifiedBy"];
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
            if (data["documentList"] && data["documentList"].constructor === Array) {
                this.documentList = [] as any;
                for (let item of data["documentList"])
                    this.documentList!.push(DocumentModel.fromJS(item));
            }
            this.assetCategory = data["assetCategory"] ? AssetCategoryModel.fromJS(data["assetCategory"]) : <any>undefined;
            if (data["assetDetail"] && data["assetDetail"].constructor === Array) {
                this.assetDetail = [] as any;
                for (let item of data["assetDetail"])
                    this.assetDetail!.push(AssetDetailModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssetModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetTagId"] = this.assetTagId;
        data["assetName"] = this.assetName;
        data["assetCategoryId"] = this.assetCategoryId;
        data["assetDescription"] = this.assetDescription;
        data["isActive"] = this.isActive;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        if (this.documentList && this.documentList.constructor === Array) {
            data["documentList"] = [];
            for (let item of this.documentList)
                data["documentList"].push(item.toJSON());
        }
        data["assetCategory"] = this.assetCategory ? this.assetCategory.toJSON() : <any>undefined;
        if (this.assetDetail && this.assetDetail.constructor === Array) {
            data["assetDetail"] = [];
            for (let item of this.assetDetail)
                data["assetDetail"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAssetModel {
    id: number;
    assetTagId?: string | undefined;
    assetName?: string | undefined;
    assetCategoryId: number;
    assetDescription?: string | undefined;
    isActive: boolean;
    createdBy: number;
    createdDate: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    documentList?: DocumentModel[] | undefined;
    assetCategory?: AssetCategoryModel | undefined;
    assetDetail?: AssetDetailModel[] | undefined;
}

export class DocumentModel implements IDocumentModel {
    fileName?: string | undefined;
    fileType?: string | undefined;
    fileLabel?: string | undefined;
    documentType?: string | undefined;
    documentId?: string | undefined;
    documentNo?: string | undefined;
    keyword?: string | undefined;
    description?: string | undefined;
    documentCategory?: string | undefined;
    fileImage?: string | undefined;

    constructor(data?: IDocumentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileLabel = data["fileLabel"];
            this.documentType = data["documentType"];
            this.documentId = data["documentId"];
            this.documentNo = data["documentNo"];
            this.keyword = data["keyword"];
            this.description = data["description"];
            this.documentCategory = data["documentCategory"];
            this.fileImage = data["fileImage"];
        }
    }

    static fromJS(data: any): DocumentModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileLabel"] = this.fileLabel;
        data["documentType"] = this.documentType;
        data["documentId"] = this.documentId;
        data["documentNo"] = this.documentNo;
        data["keyword"] = this.keyword;
        data["description"] = this.description;
        data["documentCategory"] = this.documentCategory;
        data["fileImage"] = this.fileImage;
        return data; 
    }
}

export interface IDocumentModel {
    fileName?: string | undefined;
    fileType?: string | undefined;
    fileLabel?: string | undefined;
    documentType?: string | undefined;
    documentId?: string | undefined;
    documentNo?: string | undefined;
    keyword?: string | undefined;
    description?: string | undefined;
    documentCategory?: string | undefined;
    fileImage?: string | undefined;
}

export class AssetDetailModel implements IAssetDetailModel {
    id!: number;
    assetId!: number;
    purchaseDate?: Date | undefined;
    vendorId?: number | undefined;
    cost?: number | undefined;
    warrantyExpireDate?: Date | undefined;
    warrantyDocumentId?: string | undefined;
    assetImageId?: string | undefined;
    brandName?: string | undefined;
    modelNumber?: string | undefined;
    serialNumber?: string | undefined;
    asset?: AssetModel | undefined;
    vendor?: VendorModel | undefined;

    constructor(data?: IAssetDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.assetId = data["assetId"];
            this.purchaseDate = data["purchaseDate"] ? new Date(data["purchaseDate"].toString()) : <any>undefined;
            this.vendorId = data["vendorId"];
            this.cost = data["cost"];
            this.warrantyExpireDate = data["warrantyExpireDate"] ? new Date(data["warrantyExpireDate"].toString()) : <any>undefined;
            this.warrantyDocumentId = data["warrantyDocumentId"];
            this.assetImageId = data["assetImageId"];
            this.brandName = data["brandName"];
            this.modelNumber = data["modelNumber"];
            this.serialNumber = data["serialNumber"];
            this.asset = data["asset"] ? AssetModel.fromJS(data["asset"]) : <any>undefined;
            this.vendor = data["vendor"] ? VendorModel.fromJS(data["vendor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AssetDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetId"] = this.assetId;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["cost"] = this.cost;
        data["warrantyExpireDate"] = this.warrantyExpireDate ? this.warrantyExpireDate.toISOString() : <any>undefined;
        data["warrantyDocumentId"] = this.warrantyDocumentId;
        data["assetImageId"] = this.assetImageId;
        data["brandName"] = this.brandName;
        data["modelNumber"] = this.modelNumber;
        data["serialNumber"] = this.serialNumber;
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAssetDetailModel {
    id: number;
    assetId: number;
    purchaseDate?: Date | undefined;
    vendorId?: number | undefined;
    cost?: number | undefined;
    warrantyExpireDate?: Date | undefined;
    warrantyDocumentId?: string | undefined;
    assetImageId?: string | undefined;
    brandName?: string | undefined;
    modelNumber?: string | undefined;
    serialNumber?: string | undefined;
    asset?: AssetModel | undefined;
    vendor?: VendorModel | undefined;
}

export class VendorModel implements IVendorModel {
    id!: number;
    vendorName?: string | undefined;
    isActive?: boolean | undefined;
    createdBy!: number;
    createdDate!: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;

    constructor(data?: IVendorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.vendorName = data["vendorName"];
            this.isActive = data["isActive"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = data["modifiedBy"];
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VendorModel {
        data = typeof data === 'object' ? data : {};
        let result = new VendorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vendorName"] = this.vendorName;
        data["isActive"] = this.isActive;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IVendorModel {
    id: number;
    vendorName?: string | undefined;
    isActive?: boolean | undefined;
    createdBy: number;
    createdDate: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
}

export class AssetGatePassModel implements IAssetGatePassModel {
    id!: number;
    gatePassNo?: string | undefined;
    gatePassDate!: Date;
    gatePassTypeId!: number;
    receivedBy?: number | undefined;
    remarks?: string | undefined;
    isActive!: boolean;
    gatePassStatusId?: number | undefined;
    comment?: string | undefined;
    createdBy!: number;
    createdDate!: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    gatePassStatus?: StatusModel | undefined;
    gatePassType?: GatePassTypeModel | undefined;
    createdByNavigation?: UserModel | undefined;
    receivedByNavigation?: UserModel | undefined;
    company?: CompanyModel | undefined;
    assetGatePassDetail?: AssetGatePassDetailModel[] | undefined;
    assetGatePassSenderDetail?: AssetGatePassSenderDetailModel[] | undefined;

    constructor(data?: IAssetGatePassModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.gatePassNo = data["gatePassNo"];
            this.gatePassDate = data["gatePassDate"] ? new Date(data["gatePassDate"].toString()) : <any>undefined;
            this.gatePassTypeId = data["gatePassTypeId"];
            this.receivedBy = data["receivedBy"];
            this.remarks = data["remarks"];
            this.isActive = data["isActive"];
            this.gatePassStatusId = data["gatePassStatusId"];
            this.comment = data["comment"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = data["modifiedBy"];
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
            this.gatePassStatus = data["gatePassStatus"] ? StatusModel.fromJS(data["gatePassStatus"]) : <any>undefined;
            this.gatePassType = data["gatePassType"] ? GatePassTypeModel.fromJS(data["gatePassType"]) : <any>undefined;
            this.createdByNavigation = data["createdByNavigation"] ? UserModel.fromJS(data["createdByNavigation"]) : <any>undefined;
            this.receivedByNavigation = data["receivedByNavigation"] ? UserModel.fromJS(data["receivedByNavigation"]) : <any>undefined;
            this.company = data["company"] ? CompanyModel.fromJS(data["company"]) : <any>undefined;
            if (data["assetGatePassDetail"] && data["assetGatePassDetail"].constructor === Array) {
                this.assetGatePassDetail = [] as any;
                for (let item of data["assetGatePassDetail"])
                    this.assetGatePassDetail!.push(AssetGatePassDetailModel.fromJS(item));
            }
            if (data["assetGatePassSenderDetail"] && data["assetGatePassSenderDetail"].constructor === Array) {
                this.assetGatePassSenderDetail = [] as any;
                for (let item of data["assetGatePassSenderDetail"])
                    this.assetGatePassSenderDetail!.push(AssetGatePassSenderDetailModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssetGatePassModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssetGatePassModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gatePassNo"] = this.gatePassNo;
        data["gatePassDate"] = this.gatePassDate ? this.gatePassDate.toISOString() : <any>undefined;
        data["gatePassTypeId"] = this.gatePassTypeId;
        data["receivedBy"] = this.receivedBy;
        data["remarks"] = this.remarks;
        data["isActive"] = this.isActive;
        data["gatePassStatusId"] = this.gatePassStatusId;
        data["comment"] = this.comment;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["gatePassStatus"] = this.gatePassStatus ? this.gatePassStatus.toJSON() : <any>undefined;
        data["gatePassType"] = this.gatePassType ? this.gatePassType.toJSON() : <any>undefined;
        data["createdByNavigation"] = this.createdByNavigation ? this.createdByNavigation.toJSON() : <any>undefined;
        data["receivedByNavigation"] = this.receivedByNavigation ? this.receivedByNavigation.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (this.assetGatePassDetail && this.assetGatePassDetail.constructor === Array) {
            data["assetGatePassDetail"] = [];
            for (let item of this.assetGatePassDetail)
                data["assetGatePassDetail"].push(item.toJSON());
        }
        if (this.assetGatePassSenderDetail && this.assetGatePassSenderDetail.constructor === Array) {
            data["assetGatePassSenderDetail"] = [];
            for (let item of this.assetGatePassSenderDetail)
                data["assetGatePassSenderDetail"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAssetGatePassModel {
    id: number;
    gatePassNo?: string | undefined;
    gatePassDate: Date;
    gatePassTypeId: number;
    receivedBy?: number | undefined;
    remarks?: string | undefined;
    isActive: boolean;
    gatePassStatusId?: number | undefined;
    comment?: string | undefined;
    createdBy: number;
    createdDate: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    gatePassStatus?: StatusModel | undefined;
    gatePassType?: GatePassTypeModel | undefined;
    createdByNavigation?: UserModel | undefined;
    receivedByNavigation?: UserModel | undefined;
    company?: CompanyModel | undefined;
    assetGatePassDetail?: AssetGatePassDetailModel[] | undefined;
    assetGatePassSenderDetail?: AssetGatePassSenderDetailModel[] | undefined;
}

export class StatusModel implements IStatusModel {
    id!: number;
    statusName?: string | undefined;

    constructor(data?: IStatusModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.statusName = data["statusName"];
        }
    }

    static fromJS(data: any): StatusModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusName"] = this.statusName;
        return data; 
    }
}

export interface IStatusModel {
    id: number;
    statusName?: string | undefined;
}

export class GatePassTypeModel implements IGatePassTypeModel {
    id!: number;
    typeName?: string | undefined;

    constructor(data?: IGatePassTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeName = data["typeName"];
        }
    }

    static fromJS(data: any): GatePassTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new GatePassTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeName"] = this.typeName;
        return data; 
    }
}

export interface IGatePassTypeModel {
    id: number;
    typeName?: string | undefined;
}

export class UserModel implements IUserModel {
    id!: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    empId?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    deptId?: number | undefined;
    roleId!: number;
    isActive?: boolean | undefined;
    createdBy!: number;
    createdDate!: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    token?: string | undefined;
    role?: RoleModel | undefined;
    dept?: DepartmentModel | undefined;
    userCredential?: UserCredentialModel[] | undefined;
    userSecurityAnswer?: UserSecurityAnswerModel[] | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.empId = data["empId"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.deptId = data["deptId"];
            this.roleId = data["roleId"];
            this.isActive = data["isActive"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = data["modifiedBy"];
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
            this.token = data["token"];
            this.role = data["role"] ? RoleModel.fromJS(data["role"]) : <any>undefined;
            this.dept = data["dept"] ? DepartmentModel.fromJS(data["dept"]) : <any>undefined;
            if (data["userCredential"] && data["userCredential"].constructor === Array) {
                this.userCredential = [] as any;
                for (let item of data["userCredential"])
                    this.userCredential!.push(UserCredentialModel.fromJS(item));
            }
            if (data["userSecurityAnswer"] && data["userSecurityAnswer"].constructor === Array) {
                this.userSecurityAnswer = [] as any;
                for (let item of data["userSecurityAnswer"])
                    this.userSecurityAnswer!.push(UserSecurityAnswerModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["empId"] = this.empId;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["deptId"] = this.deptId;
        data["roleId"] = this.roleId;
        data["isActive"] = this.isActive;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["token"] = this.token;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["dept"] = this.dept ? this.dept.toJSON() : <any>undefined;
        if (this.userCredential && this.userCredential.constructor === Array) {
            data["userCredential"] = [];
            for (let item of this.userCredential)
                data["userCredential"].push(item.toJSON());
        }
        if (this.userSecurityAnswer && this.userSecurityAnswer.constructor === Array) {
            data["userSecurityAnswer"] = [];
            for (let item of this.userSecurityAnswer)
                data["userSecurityAnswer"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserModel {
    id: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    empId?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    deptId?: number | undefined;
    roleId: number;
    isActive?: boolean | undefined;
    createdBy: number;
    createdDate: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    token?: string | undefined;
    role?: RoleModel | undefined;
    dept?: DepartmentModel | undefined;
    userCredential?: UserCredentialModel[] | undefined;
    userSecurityAnswer?: UserSecurityAnswerModel[] | undefined;
}

export class RoleModel implements IRoleModel {
    id!: number;
    roleName?: string | undefined;
    roleDescription?: string | undefined;
    isActive!: boolean;
    createdBy!: number;
    createdDate!: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    roleMenu?: RoleMenuModel[] | undefined;
    roleFunction?: RoleFunctionModel[] | undefined;
    functionList?: FunctionModel[] | undefined;
    menuList?: MenuModel[] | undefined;

    constructor(data?: IRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleName = data["roleName"];
            this.roleDescription = data["roleDescription"];
            this.isActive = data["isActive"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = data["modifiedBy"];
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
            if (data["roleMenu"] && data["roleMenu"].constructor === Array) {
                this.roleMenu = [] as any;
                for (let item of data["roleMenu"])
                    this.roleMenu!.push(RoleMenuModel.fromJS(item));
            }
            if (data["roleFunction"] && data["roleFunction"].constructor === Array) {
                this.roleFunction = [] as any;
                for (let item of data["roleFunction"])
                    this.roleFunction!.push(RoleFunctionModel.fromJS(item));
            }
            if (data["functionList"] && data["functionList"].constructor === Array) {
                this.functionList = [] as any;
                for (let item of data["functionList"])
                    this.functionList!.push(FunctionModel.fromJS(item));
            }
            if (data["menuList"] && data["menuList"].constructor === Array) {
                this.menuList = [] as any;
                for (let item of data["menuList"])
                    this.menuList!.push(MenuModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleName"] = this.roleName;
        data["roleDescription"] = this.roleDescription;
        data["isActive"] = this.isActive;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        if (this.roleMenu && this.roleMenu.constructor === Array) {
            data["roleMenu"] = [];
            for (let item of this.roleMenu)
                data["roleMenu"].push(item.toJSON());
        }
        if (this.roleFunction && this.roleFunction.constructor === Array) {
            data["roleFunction"] = [];
            for (let item of this.roleFunction)
                data["roleFunction"].push(item.toJSON());
        }
        if (this.functionList && this.functionList.constructor === Array) {
            data["functionList"] = [];
            for (let item of this.functionList)
                data["functionList"].push(item.toJSON());
        }
        if (this.menuList && this.menuList.constructor === Array) {
            data["menuList"] = [];
            for (let item of this.menuList)
                data["menuList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoleModel {
    id: number;
    roleName?: string | undefined;
    roleDescription?: string | undefined;
    isActive: boolean;
    createdBy: number;
    createdDate: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    roleMenu?: RoleMenuModel[] | undefined;
    roleFunction?: RoleFunctionModel[] | undefined;
    functionList?: FunctionModel[] | undefined;
    menuList?: MenuModel[] | undefined;
}

export class RoleMenuModel implements IRoleMenuModel {
    id!: number;
    roleId!: number;
    parentMenuId!: number;
    menuId!: number;

    constructor(data?: IRoleMenuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleId = data["roleId"];
            this.parentMenuId = data["parentMenuId"];
            this.menuId = data["menuId"];
        }
    }

    static fromJS(data: any): RoleMenuModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleMenuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["parentMenuId"] = this.parentMenuId;
        data["menuId"] = this.menuId;
        return data; 
    }
}

export interface IRoleMenuModel {
    id: number;
    roleId: number;
    parentMenuId: number;
    menuId: number;
}

export class RoleFunctionModel implements IRoleFunctionModel {
    id!: number;
    roleId!: number;
    functionId!: number;
    isActive!: boolean;

    constructor(data?: IRoleFunctionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleId = data["roleId"];
            this.functionId = data["functionId"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): RoleFunctionModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleFunctionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["functionId"] = this.functionId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IRoleFunctionModel {
    id: number;
    roleId: number;
    functionId: number;
    isActive: boolean;
}

export class FunctionModel implements IFunctionModel {
    id!: number;
    functionCode?: string | undefined;
    functionName?: string | undefined;
    functionDescription?: string | undefined;

    constructor(data?: IFunctionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.functionCode = data["functionCode"];
            this.functionName = data["functionName"];
            this.functionDescription = data["functionDescription"];
        }
    }

    static fromJS(data: any): FunctionModel {
        data = typeof data === 'object' ? data : {};
        let result = new FunctionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["functionCode"] = this.functionCode;
        data["functionName"] = this.functionName;
        data["functionDescription"] = this.functionDescription;
        return data; 
    }
}

export interface IFunctionModel {
    id: number;
    functionCode?: string | undefined;
    functionName?: string | undefined;
    functionDescription?: string | undefined;
}

export class MenuModel implements IMenuModel {
    id!: number;
    menuTitle?: string | undefined;
    parentMenuId?: number | undefined;
    menuLink?: string | undefined;
    templateUrl?: string | undefined;
    controller?: string | undefined;
    controllerAs?: string | undefined;
    isDisabled!: boolean;
    isStateRequired!: boolean;
    displayOrder!: number;
    tag?: string | undefined;

    constructor(data?: IMenuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.menuTitle = data["menuTitle"];
            this.parentMenuId = data["parentMenuId"];
            this.menuLink = data["menuLink"];
            this.templateUrl = data["templateUrl"];
            this.controller = data["controller"];
            this.controllerAs = data["controllerAs"];
            this.isDisabled = data["isDisabled"];
            this.isStateRequired = data["isStateRequired"];
            this.displayOrder = data["displayOrder"];
            this.tag = data["tag"];
        }
    }

    static fromJS(data: any): MenuModel {
        data = typeof data === 'object' ? data : {};
        let result = new MenuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["menuTitle"] = this.menuTitle;
        data["parentMenuId"] = this.parentMenuId;
        data["menuLink"] = this.menuLink;
        data["templateUrl"] = this.templateUrl;
        data["controller"] = this.controller;
        data["controllerAs"] = this.controllerAs;
        data["isDisabled"] = this.isDisabled;
        data["isStateRequired"] = this.isStateRequired;
        data["displayOrder"] = this.displayOrder;
        data["tag"] = this.tag;
        return data; 
    }
}

export interface IMenuModel {
    id: number;
    menuTitle?: string | undefined;
    parentMenuId?: number | undefined;
    menuLink?: string | undefined;
    templateUrl?: string | undefined;
    controller?: string | undefined;
    controllerAs?: string | undefined;
    isDisabled: boolean;
    isStateRequired: boolean;
    displayOrder: number;
    tag?: string | undefined;
}

export class UserCredentialModel implements IUserCredentialModel {
    id!: number;
    userId!: number;
    password?: string | undefined;
    passwordKey?: string | undefined;
    attempted?: number | undefined;

    constructor(data?: IUserCredentialModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.password = data["password"];
            this.passwordKey = data["passwordKey"];
            this.attempted = data["attempted"];
        }
    }

    static fromJS(data: any): UserCredentialModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserCredentialModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["password"] = this.password;
        data["passwordKey"] = this.passwordKey;
        data["attempted"] = this.attempted;
        return data; 
    }
}

export interface IUserCredentialModel {
    id: number;
    userId: number;
    password?: string | undefined;
    passwordKey?: string | undefined;
    attempted?: number | undefined;
}

export class UserSecurityAnswerModel implements IUserSecurityAnswerModel {
    id!: number;
    userId!: number;
    securityQuestionId!: number;
    answer?: string | undefined;

    constructor(data?: IUserSecurityAnswerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.securityQuestionId = data["securityQuestionId"];
            this.answer = data["answer"];
        }
    }

    static fromJS(data: any): UserSecurityAnswerModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserSecurityAnswerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["securityQuestionId"] = this.securityQuestionId;
        data["answer"] = this.answer;
        return data; 
    }
}

export interface IUserSecurityAnswerModel {
    id: number;
    userId: number;
    securityQuestionId: number;
    answer?: string | undefined;
}

export class CompanyModel implements ICompanyModel {
    id!: number;
    companyName?: string | undefined;
    address1?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    webSiteUrl?: string | undefined;
    companyLogoId?: string | undefined;
    isActive?: boolean | undefined;
    createdBy!: number;
    createdDate!: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    companyLogo?: DocumentModel | undefined;

    constructor(data?: ICompanyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.companyName = data["companyName"];
            this.address1 = data["address1"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.country = data["country"];
            this.webSiteUrl = data["webSiteUrl"];
            this.companyLogoId = data["companyLogoId"];
            this.isActive = data["isActive"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? new Date(data["createdDate"].toString()) : <any>undefined;
            this.modifiedBy = data["modifiedBy"];
            this.modifiedDate = data["modifiedDate"] ? new Date(data["modifiedDate"].toString()) : <any>undefined;
            this.companyLogo = data["companyLogo"] ? DocumentModel.fromJS(data["companyLogo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["address1"] = this.address1;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["country"] = this.country;
        data["webSiteUrl"] = this.webSiteUrl;
        data["companyLogoId"] = this.companyLogoId;
        data["isActive"] = this.isActive;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["companyLogo"] = this.companyLogo ? this.companyLogo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICompanyModel {
    id: number;
    companyName?: string | undefined;
    address1?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    webSiteUrl?: string | undefined;
    companyLogoId?: string | undefined;
    isActive?: boolean | undefined;
    createdBy: number;
    createdDate: Date;
    modifiedBy?: number | undefined;
    modifiedDate?: Date | undefined;
    companyLogo?: DocumentModel | undefined;
}

export class AssetGatePassDetailModel implements IAssetGatePassDetailModel {
    id!: number;
    assetGatePassId?: number | undefined;
    assetId?: number | undefined;
    sendQty?: number | undefined;
    sendQtyUnitId?: number | undefined;
    receivedQty?: number | undefined;
    receivedQtyUnitId?: number | undefined;
    assetTypeId?: number | undefined;
    asset?: AssetModel | undefined;
    assetType?: GatePassTypeModel | undefined;
    receivedQtyUnit?: QuantityUnitModel | undefined;
    sendQtyUnit?: QuantityUnitModel | undefined;

    constructor(data?: IAssetGatePassDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.assetGatePassId = data["assetGatePassId"];
            this.assetId = data["assetId"];
            this.sendQty = data["sendQty"];
            this.sendQtyUnitId = data["sendQtyUnitId"];
            this.receivedQty = data["receivedQty"];
            this.receivedQtyUnitId = data["receivedQtyUnitId"];
            this.assetTypeId = data["assetTypeId"];
            this.asset = data["asset"] ? AssetModel.fromJS(data["asset"]) : <any>undefined;
            this.assetType = data["assetType"] ? GatePassTypeModel.fromJS(data["assetType"]) : <any>undefined;
            this.receivedQtyUnit = data["receivedQtyUnit"] ? QuantityUnitModel.fromJS(data["receivedQtyUnit"]) : <any>undefined;
            this.sendQtyUnit = data["sendQtyUnit"] ? QuantityUnitModel.fromJS(data["sendQtyUnit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AssetGatePassDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssetGatePassDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetGatePassId"] = this.assetGatePassId;
        data["assetId"] = this.assetId;
        data["sendQty"] = this.sendQty;
        data["sendQtyUnitId"] = this.sendQtyUnitId;
        data["receivedQty"] = this.receivedQty;
        data["receivedQtyUnitId"] = this.receivedQtyUnitId;
        data["assetTypeId"] = this.assetTypeId;
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["assetType"] = this.assetType ? this.assetType.toJSON() : <any>undefined;
        data["receivedQtyUnit"] = this.receivedQtyUnit ? this.receivedQtyUnit.toJSON() : <any>undefined;
        data["sendQtyUnit"] = this.sendQtyUnit ? this.sendQtyUnit.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAssetGatePassDetailModel {
    id: number;
    assetGatePassId?: number | undefined;
    assetId?: number | undefined;
    sendQty?: number | undefined;
    sendQtyUnitId?: number | undefined;
    receivedQty?: number | undefined;
    receivedQtyUnitId?: number | undefined;
    assetTypeId?: number | undefined;
    asset?: AssetModel | undefined;
    assetType?: GatePassTypeModel | undefined;
    receivedQtyUnit?: QuantityUnitModel | undefined;
    sendQtyUnit?: QuantityUnitModel | undefined;
}

export class QuantityUnitModel implements IQuantityUnitModel {
    id!: number;
    unit?: string | undefined;

    constructor(data?: IQuantityUnitModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.unit = data["unit"];
        }
    }

    static fromJS(data: any): QuantityUnitModel {
        data = typeof data === 'object' ? data : {};
        let result = new QuantityUnitModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unit"] = this.unit;
        return data; 
    }
}

export interface IQuantityUnitModel {
    id: number;
    unit?: string | undefined;
}

export class AssetGatePassSenderDetailModel implements IAssetGatePassSenderDetailModel {
    id!: number;
    assetGatePassId!: number;
    name?: string | undefined;
    companyName?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IAssetGatePassSenderDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.assetGatePassId = data["assetGatePassId"];
            this.name = data["name"];
            this.companyName = data["companyName"];
            this.address = data["address"];
            this.phone = data["phone"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): AssetGatePassSenderDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssetGatePassSenderDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assetGatePassId"] = this.assetGatePassId;
        data["name"] = this.name;
        data["companyName"] = this.companyName;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data; 
    }
}

export interface IAssetGatePassSenderDetailModel {
    id: number;
    assetGatePassId: number;
    name?: string | undefined;
    companyName?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class LoginDetails implements ILoginDetails {
    userId?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LoginDetails {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginDetails {
    userId?: string | undefined;
    password?: string | undefined;
}

export class DashboardModel implements IDashboardModel {
    gatPassId!: number;
    approveGatePass!: number;
    pendingGatePass!: number;
    rejectGatepass!: number;
    approveGatePassList?: AssetGatePassModel[] | undefined;
    pendingGatePassList?: AssetGatePassModel[] | undefined;
    rejectGatepassList?: AssetGatePassModel[] | undefined;

    constructor(data?: IDashboardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatPassId = data["gatPassId"];
            this.approveGatePass = data["approveGatePass"];
            this.pendingGatePass = data["pendingGatePass"];
            this.rejectGatepass = data["rejectGatepass"];
            if (data["approveGatePassList"] && data["approveGatePassList"].constructor === Array) {
                this.approveGatePassList = [] as any;
                for (let item of data["approveGatePassList"])
                    this.approveGatePassList!.push(AssetGatePassModel.fromJS(item));
            }
            if (data["pendingGatePassList"] && data["pendingGatePassList"].constructor === Array) {
                this.pendingGatePassList = [] as any;
                for (let item of data["pendingGatePassList"])
                    this.pendingGatePassList!.push(AssetGatePassModel.fromJS(item));
            }
            if (data["rejectGatepassList"] && data["rejectGatepassList"].constructor === Array) {
                this.rejectGatepassList = [] as any;
                for (let item of data["rejectGatepassList"])
                    this.rejectGatepassList!.push(AssetGatePassModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardModel {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatPassId"] = this.gatPassId;
        data["approveGatePass"] = this.approveGatePass;
        data["pendingGatePass"] = this.pendingGatePass;
        data["rejectGatepass"] = this.rejectGatepass;
        if (this.approveGatePassList && this.approveGatePassList.constructor === Array) {
            data["approveGatePassList"] = [];
            for (let item of this.approveGatePassList)
                data["approveGatePassList"].push(item.toJSON());
        }
        if (this.pendingGatePassList && this.pendingGatePassList.constructor === Array) {
            data["pendingGatePassList"] = [];
            for (let item of this.pendingGatePassList)
                data["pendingGatePassList"].push(item.toJSON());
        }
        if (this.rejectGatepassList && this.rejectGatepassList.constructor === Array) {
            data["rejectGatepassList"] = [];
            for (let item of this.rejectGatepassList)
                data["rejectGatepassList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDashboardModel {
    gatPassId: number;
    approveGatePass: number;
    pendingGatePass: number;
    rejectGatepass: number;
    approveGatePassList?: AssetGatePassModel[] | undefined;
    pendingGatePassList?: AssetGatePassModel[] | undefined;
    rejectGatepassList?: AssetGatePassModel[] | undefined;
}

export class ReportModel implements IReportModel {
    gatePassNo?: string | undefined;
    gatePassDate?: string | undefined;
    senderName?: string | undefined;
    sendAddress?: string | undefined;
    remarks?: string | undefined;
    gatePassStatus?: string | undefined;
    gatePassType?: string | undefined;
    assetTagId?: string | undefined;
    assetName?: string | undefined;
    assetCategoryName?: string | undefined;
    receivedBy?: string | undefined;
    createdBy?: string | undefined;

    constructor(data?: IReportModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatePassNo = data["gatePassNo"];
            this.gatePassDate = data["gatePassDate"];
            this.senderName = data["senderName"];
            this.sendAddress = data["sendAddress"];
            this.remarks = data["remarks"];
            this.gatePassStatus = data["gatePassStatus"];
            this.gatePassType = data["gatePassType"];
            this.assetTagId = data["assetTagId"];
            this.assetName = data["assetName"];
            this.assetCategoryName = data["assetCategoryName"];
            this.receivedBy = data["receivedBy"];
            this.createdBy = data["createdBy"];
        }
    }

    static fromJS(data: any): ReportModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReportModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatePassNo"] = this.gatePassNo;
        data["gatePassDate"] = this.gatePassDate;
        data["senderName"] = this.senderName;
        data["sendAddress"] = this.sendAddress;
        data["remarks"] = this.remarks;
        data["gatePassStatus"] = this.gatePassStatus;
        data["gatePassType"] = this.gatePassType;
        data["assetTagId"] = this.assetTagId;
        data["assetName"] = this.assetName;
        data["assetCategoryName"] = this.assetCategoryName;
        data["receivedBy"] = this.receivedBy;
        data["createdBy"] = this.createdBy;
        return data; 
    }
}

export interface IReportModel {
    gatePassNo?: string | undefined;
    gatePassDate?: string | undefined;
    senderName?: string | undefined;
    sendAddress?: string | undefined;
    remarks?: string | undefined;
    gatePassStatus?: string | undefined;
    gatePassType?: string | undefined;
    assetTagId?: string | undefined;
    assetName?: string | undefined;
    assetCategoryName?: string | undefined;
    receivedBy?: string | undefined;
    createdBy?: string | undefined;
}

export class UserRoleModel implements IUserRoleModel {
    userId!: number;
    roleId!: number;
    menuList?: MenuModel[] | undefined;
    functionList?: FunctionModel[] | undefined;

    constructor(data?: IUserRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.roleId = data["roleId"];
            if (data["menuList"] && data["menuList"].constructor === Array) {
                this.menuList = [] as any;
                for (let item of data["menuList"])
                    this.menuList!.push(MenuModel.fromJS(item));
            }
            if (data["functionList"] && data["functionList"].constructor === Array) {
                this.functionList = [] as any;
                for (let item of data["functionList"])
                    this.functionList!.push(FunctionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        if (this.menuList && this.menuList.constructor === Array) {
            data["menuList"] = [];
            for (let item of this.menuList)
                data["menuList"].push(item.toJSON());
        }
        if (this.functionList && this.functionList.constructor === Array) {
            data["functionList"] = [];
            for (let item of this.functionList)
                data["functionList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserRoleModel {
    userId: number;
    roleId: number;
    menuList?: MenuModel[] | undefined;
    functionList?: FunctionModel[] | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}